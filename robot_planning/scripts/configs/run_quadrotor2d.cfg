[baseline_agent]
type = simulated_robot
data_type = numpy
start_state = [-4, 1.0, 0.0, 0.0, 0.0, 0.0]
dynamics = my_dynamics1
steps_per_action = 1
#controller = my_controller1
controller = baseline_mppi_controller
cost_evaluator = baseline_cost_evaluator

[cbf_agent]
type = simulated_robot
data_type = numpy
start_state = [-4, 1.0, 0.0, 0.0, 0.0, 0.0]
dynamics = my_dynamics1
steps_per_action = 1
controller = cbf_mppi_controller
cost_evaluator = cbf_cost_evaluator

[cbf_inefficient_agent]
type = simulated_robot
data_type = numpy
start_state = [-4, 1.0, 0.0, 0.0, 0.0, 0.0]
dynamics = my_dynamics1
steps_per_action = 1
controller = cbf_inefficient_mppi_controller
cost_evaluator = cbf_cost_evaluator

[ncbf_agent]
type = simulated_robot
data_type = numpy
start_state = [-4, 1.0, 0.0, 0.0, 0.0, 0.0]
dynamics = my_dynamics1
steps_per_action = 1
controller = ncbf_mppi_controller
cost_evaluator = ncbf_cost_evaluator

[CEM_agent]
type = simulated_robot
data_type = numpy
start_state = [-4, 1.0, 0.0, 0.0, 0.0, 0.0]
dynamics = my_dynamics1
steps_per_action = 1
controller = CEM_controller
cost_evaluator = ncbf_cost_evaluator

; ------------------------------------------------------

[logger]
type = drone_2d_npz_logger
experiment_name = drone_2d
batch_code = 0
goal_checker = my_goal_checker1
collision_checker = my_collision_checker_for_collision
num_states = 6

[my_controller1]
type = Quadrotor2D_OpenLoop
dynamics = my_dynamics1
cost_evaluator = baseline_cost_evaluator
control_dim = 2
inverse_temperature = 1
control_horizon = 10
stochastic_trajectories_sampler = my_stochastic_trajectories_sampler1

; ---------------------------------------------------------------------

[baseline_mppi_controller]
type = MPPI
dynamics = my_dynamics1
cost_evaluator = baseline_cost_evaluator
control_dim = 2
inverse_temperature = 1
control_horizon = 10
stochastic_trajectories_sampler = baseline_stochastic_trajectories_sampler
min_controls = [-0.1, -0.1]
max_controls = [0.1, 0.1]

[CEM_controller]
type = CEMMPC
dynamics = my_dynamics1
cost_evaluator = baseline_cost_evaluator
elite_ratio = 0.001
control_dim = 2
inverse_temperature = 1
control_horizon = 10
stochastic_trajectories_sampler = baseline_stochastic_trajectories_sampler
min_controls = [-0.1, -0.1]
max_controls = [0.1, 0.1]

[cbf_mppi_controller]
type = MPPI
dynamics = my_dynamics1
cost_evaluator = cbf_cost_evaluator
control_dim = 2
inverse_temperature = 1
control_horizon = 10
repair_horizon = 4
repair_steps = 0
;repair_steps = 4
stochastic_trajectories_sampler = cbf_stochastic_trajectories_sampler
min_controls = [-0.1, -0.1]
max_controls = [0.1, 0.1]

[cbf_inefficient_mppi_controller]
type = MPPI
dynamics = my_dynamics1
cost_evaluator = cbf_cost_evaluator
control_dim = 2
inverse_temperature = 1
control_horizon = 10
repair_horizon = 4
repair_steps = 0
;repair_steps = 4
stochastic_trajectories_sampler = cbf_inefficient_stochastic_trajectories_sampler
min_controls = [-0.1, -0.1]
max_controls = [0.1, 0.1]

[ncbf_mppi_controller]
type = MPPI
dynamics = my_dynamics1
cost_evaluator = ncbf_cost_evaluator
control_dim = 2
inverse_temperature = 1
control_horizon = 10
repair_horizon = 4
repair_steps = 0
;repair_steps = 4
stochastic_trajectories_sampler = ncbf_stochastic_trajectories_sampler
min_controls = [-0.1, -0.1]
max_controls = [0.1, 0.1]

; ---------------------------------------------------------------------

[baseline_cost_evaluator]
type = quadratic_cost
collision_cost = 30
Q = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
QN = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
R = [100.0, 100.0]
goal_checker = my_goal_checker1
collision_checker = my_collision_checker_for_collision
goal_cost = 1000

[cbf_cost_evaluator]
type = quadrotor_2d_cbf_cost_evaluator
include_cbf_cost = True
collision_cost = 30
cbf_alpha = 0.9
barrier_net = my_barrier_net
Q = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
QN = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
R = [100.0, 100.0]
goal_checker = my_goal_checker1
collision_checker = my_collision_checker_for_collision
goal_cost = 1000

[ncbf_cost_evaluator]
type = quadrotor_2d_mppi_ncbf_cost_evaluator
include_cbf_cost = True
collision_cost = 100000
Q = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
QN = [30.0, 30.0, 50.0, 10.0, 10.0, 10.0]
R = [100.0, 100.0]
goal_checker = my_goal_checker1
collision_checker = my_collision_checker_for_collision
goal_cost = 1000

; ---------------------------------------------------------------------

[baseline_stochastic_trajectories_sampler]
type = MPPI_stochastic_trajectories_sampler
number_of_processes = 12
number_of_trajectories = 1000
uncontrolled_trajectories_portion = 0.0
noise_sampler = my_noise_sampler1

[CEM_stochastic_trajectories_sampler]
type = MPPI_stochastic_trajectories_sampler
number_of_processes = 12
number_of_trajectories = 1000
uncontrolled_trajectories_portion = 0.0
noise_sampler = my_noise_sampler1

[cbf_stochastic_trajectories_sampler]
type = MPPI_CBF_stochastic_trajectories_sampler
efficient_sampling = True
number_of_processes = 12
number_of_trajectories = 1000
uncontrolled_trajectories_portion = 0.0
noise_sampler = my_noise_sampler1

[cbf_inefficient_stochastic_trajectories_sampler]
type = MPPI_CBF_stochastic_trajectories_sampler
efficient_sampling = False
number_of_processes = 12
number_of_trajectories = 1000
uncontrolled_trajectories_portion = 0.0
noise_sampler = my_noise_sampler1

[ncbf_stochastic_trajectories_sampler]
type = MPPI_NCBF_stochastic_trajectories_sampler
number_of_trajectories = 1000
uncontrolled_trajectories_portion = 0.0
noise_sampler = my_noise_sampler1

; ---------------------------------------------------------------------

[my_noise_sampler1]
type = gaussian_noise_sampler
mean = [0, 0]
covariance = [[0.01, 0], [0, 0.01]]
seed = 12345

[my_dynamics1]
type = quadrotor_dynamics_2d
delta_t = 0.05
mass = 0.01
I = 0.00016499
rho = 1.0
kinematics = my_kinematics1

[my_kinematics1]
type = quadrotor_kinematics_2d
l = 0.07
R = 0.02

[my_goal_checker1]
type = quadrotor_2d_goal_checker
goal_state = [10.0, 1.0, 0.0, 1.0, 0.0, 0.0]


[my_collision_checker_for_collision]
type = quadrotor_2d_collision_checker
#obstacles = [[0.0, 0.0], [0.0, 2.0], [1.0, 2.0], [-1.0, 2.0], [-2.0, 2.0], [-3.0, 2.0], [-4.0, 2.0]]
#obstacles_radius = [1.0, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8]
obstacles = [[-4.0, 2.0], [-3.0, 2.0], [-2.0, 2.0], [-1.0, 2.0], [0.0, 1.0], [1.0, 0.93], [2.0, 1.0], [3.0, 2.0], [4.0, 2.0]]
obstacles_radius = [0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8]

kinematics = my_kinematics1

; ------------------------------------------------

[renderer1]
type = quadrotor_2d_matplotlib_blit
trajectories_rendering = True
path_rendering = True
;
dynamics = my_dynamics1
equal_aspect_ratio = True
grid_on = False
xaxis_range = [-5, 6]
yaxis_range = [-0.01, 1.5]
figure_size = [15, 8]
figure_dpi = 150
auto_range = False
save_animation = False


[renderer2]
type = quadrotor_2d_matplotlib
dynamics = my_dynamics1
equal_aspect_ratio = True
grid_on = False
xaxis_range = [-5, 5]
yaxis_range = [-0.5, 2]
figure_size = [9, 9]
figure_dpi = 81
auto_range = False
trajectories_rendering = False
save_animation = False

